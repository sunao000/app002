<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>自転車ルート比較＋休憩（最適化付き） v6.0.0</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map{height:500px;width:100%}
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{display:flex;flex-wrap:wrap;align-items:flex-start;justify-content:space-between;padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px}
#searchResults{position:absolute;z-index:1000;width:260px;max-height:200px;overflow-y:auto;margin:4px 0 0;padding:0;list-style:none;border:1px solid #ccc;background:#fff}
#searchResults li{padding:4px 8px;cursor:pointer}
#searchResults li:hover{background:#e0e0e0}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.9rem}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
.group{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:6px}
.small{font-size:.88em;color:#555}
details{border:1px solid #ddd;border-radius:6px;padding:6px;background:#fff}
#charts{display:none}
#charts canvas{width:800px;height:400px}
hr{border:none;border-top:1px solid #eee;margin:8px 0}
label.chk{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
input[type=number]{width:90px}
th,td{font-size:0.92rem}
.badge{display:inline-block;padding:1px 6px;border-radius:999px;background:#eef;border:1px solid #cdd;font-size:.8em}
table.clean td,table.clean th{padding:4px;border-bottom:1px solid #eee}
</style>
</head>
<body>

<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="searchBtn">検索</button>
  <label><input type="checkbox" id="nearbyOnly"> 近くの場所のみ</label>
  <button id="locBtn">現在地追加</button>

  <input id="restToggle" type="checkbox" checked hidden>
  <button id="restModeBtn">休憩込み: ON</button>

  <button id="btnDownloadTime"  disabled>PNG（時間×累積kJ）</button>
  <button id="btnDownloadDist"  disabled>PNG（距離×累積kJ）</button>

  <label>基準
    <select id="restBasis">
      <option value="time">時間</option>
      <option value="energy" selected>kJ</option>
      <option value="distance">距離</option>
    </select>
  </label>

  <span id="timeBox" class="group" style="display:none">
    <label>間隔 <input id="restMinutes" type="number" value="60" min="15" step="5"> 分</label>
  </span>
  <span id="energyBox" class="group">
    <label>しきい値 <input id="restKJ" type="number" value="500" min="100" step="50"> kJ</label>
    <button type="button" class="presetKJ" data-kj="400">400</button>
    <button type="button" class="presetKJ" data-kj="500">500</button>
    <button type="button" class="presetKJ" data-kj="650">650</button>
  </span>
  <span id="distanceBox" class="group" style="display:none">
    <label>しきい値 <input id="restKm" type="number" value="20" min="1" step="1"> km</label>
  </span>

  <select id="profileSelect">
    <option value="cycling-road" selected>ロードバイク</option>
    <option value="cycling-regular">自転車（一般）</option>
  </select>
  <button id="drawBtn">ルート表示</button>

  <label><input type="checkbox" id="chkShortest" checked> 最短</label>
  <label><input type="checkbox" id="chkFastest" checked> 最速</label>
  <label><input type="checkbox" id="chkSlope" checked> 勾配</label>
</div>

<!-- 休憩地点まわりのPOI -->
<div class="section">
  <details open>
    <summary>休憩地点まわりのPOI</summary>
    <div class="group">
      <label class="chk"><input type="checkbox" id="poiToggle"> POIを表示する</label>
      <label>半径 <input id="poiRadius" type="number" value="300" min="50" step="50"> m</label>
    </div>
    <div class="group">
      <label class="chk"><input type="checkbox" class="poiCat" value="conv" checked> コンビニ</label>
      <label class="chk"><input type="checkbox" class="poiCat" value="super"> スーパー</label>
      <label class="chk"><input type="checkbox" class="poiCat" value="drug"> ドラッグストア</label>
    </div>
  </details>
</div>

<!-- 休憩ロジック設定 -->
<div class="section">
  <div class="group">
    <label>体重 <input id="riderWeight" type="number" value="65" min="30" max="150" step="0.5"> kg</label>
    <label>バイク重量 <input id="bikeWeight" type="number" value="10" min="5" max="30" step="0.1"> kg</label>
  </div>

  <details open><summary>積算トリガ（時間/kJ/距離）</summary>
    <div class="group">
      <label class="chk"><input type="checkbox" id="optAccum" checked> 積算トリガを使う</label>
      <span class="small">※ 上の「基準」と「しきい値/間隔」設定を使用</span>
    </div>
  </details>

  <details open><summary>統計トリガ（平均/分散サンプリング）</summary>
    <div class="group">
      <label class="chk"><input type="checkbox" id="optStatTrigger"> 統計トリガを使う</label>
      <span class="small">※ ON時は下の平均/分散で休憩ターゲットを逐次サンプル（時間は対象外）</span>
    </div>
    <div class="group">
      <label>指標
        <select id="statMetric">
          <option value="distance" selected>走行距離（km）</option>
          <option value="energy">消費エネルギー（kJ）</option>
        </select>
      </label>
      <label>平均 <input id="statMean" type="number" value="20" min="0.1" step="0.1"> <span id="statMeanUnit">km</span></label>
      <label>分散 <input id="statVar" type="number" value="9" min="0" step="0.1"> <span id="statVarUnit">km²</span></label>
      <label>下限 <input id="statMin" type="number" value="5" min="0.1" step="0.1"> <span id="statMinUnit">km</span></label>
    </div>
    <div class="group">
      <label>乱数シード <input id="statSeed" type="number" value="12345" step="1"></label>
      <button type="button" id="statResampleBtn">次のターゲットを再サンプル</button>
    </div>
  </details>

  <details><summary>詳細設定（簡易エネルギー）</summary>
    <div class="small">平坦係数 (kJ/km)</div>
    <label>平坦係数 <input id="flatKJperKm" type="number" value="18" min="10" max="30" step="0.5"> kJ/km</label>
  </details>
</div>

<!-- 最適化（候補3件×各休憩 → 組合せ探索） -->
<div class="section">
  <details open>
    <summary>休憩候補の組合せ最適化 <span class="badge">近い順3件×各休憩</span></summary>
    <div class="group">
      <button type="button" id="btnCollectCands">休憩候補を収集</button>
      <button type="button" id="btnOptimize" disabled>組合せ最適化して適用</button>
      <span id="optStatus" class="small"></span>
    </div>
    <div class="group">
      <table class="clean">
        <thead>
          <tr><th>指標</th><th>使う</th><th>目標平均</th><th>目標分散</th><th>重み</th></tr>
        </thead>
        <tbody>
          <tr>
            <td>距離 (km)</td>
            <td><input type="checkbox" id="useDist" checked></td>
            <td><input type="number" id="meanDist" value="20" step="0.1"></td>
            <td><input type="number" id="varDist" value="9" step="0.1"></td>
            <td><input type="number" id="wDist" value="1.0" step="0.1"></td>
          </tr>
          <tr>
            <td>時間 (分)</td>
            <td><input type="checkbox" id="useTime"></td>
            <td><input type="number" id="meanTime" value="60" step="1"></td>
            <td><input type="number" id="varTime" value="400" step="1"></td>
            <td><input type="number" id="wTime" value="1.0" step="0.1"></td>
          </tr>
          <tr>
            <td>エネルギー (kJ)</td>
            <td><input type="checkbox" id="useEner"></td>
            <td><input type="number" id="meanKJ" value="500" step="1"></td>
            <td><input type="number" id="varKJ" value="100" step="1"></td>
            <td><input type="number" id="wEner" value="1.0" step="0.1"></td>
          </tr>
        </tbody>
      </table>
      <label>ビーム幅 <input id="beamWidth" type="number" value="30" min="3" step="1"> </label>
    </div>
    <div class="small" id="optResult">（未実行）</div>
  </details>
</div>

<ul id="searchResults" hidden></ul>
<ul id="pointList"></ul>
<div id="map"></div>

<div id="summary">
  <div id="routeInfo"></div>
  <div id="distanceScore" class="muted"></div>
</div>

<div class="section" id="legStatsSection">
  <details open>
    <summary>区間集計（地点→次の地点の区間ごと）</summary>
    <div class="group">
      <label>指標
        <select id="legMetric">
          <option value="distance" selected>距離（km）</option>
          <option value="energy">エネルギー（kJ）</option>
        </select>
      </label>
      <label class="chk"><input type="checkbox" id="legIncludeRest" checked> 休憩地点を含める</label>
      <button type="button" id="btnCalcLegs">再計算</button>
    </div>
    <div class="small" id="legSummary">未計算</div>
    <div style="overflow:auto; max-height:240px;">
      <table id="legTable" style="border-collapse:collapse; width:100%;">
        <thead>
          <tr>
            <th style="text-align:left; border-bottom:1px solid #ddd; padding:4px;">#</th>
            <th style="text-align:left; border-bottom:1px solid #ddd; padding:4px;">区間</th>
            <th style="text-align:right; border-bottom:1px solid #ddd; padding:4px;">距離 (km)</th>
            <th style="text-align:right; border-bottom:1px solid #ddd; padding:4px;">エネルギー (kJ)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </details>
</div>

<div class="section">
  <details open>
    <summary>休憩トリガ・ヒット状況（TRIGGER/HIT）</summary>
    <div id="restDebug" class="small"></div>
  </details>
</div>

<div id="charts"><canvas id="energyChart"></canvas></div>

<script>
/* ===== 定数 ===== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9';  // ←★あなたの ORS API キー
const ORS_ROOT = 'https://api.openrouteservice.org';

/* ===== ヘルパ ===== */
function $(id){return document.getElementById(id);}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function icon(c){return new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/'+c+'-dot.png',iconSize:[32,32],iconAnchor:[16,32]});}
const ICONS = {start:icon('green'),via:icon('blue'),goal:icon('red')};
function formatDist(d){return (d/1000).toFixed(2)+' km';}
function formatDur(s){var m=Math.round(s/60);return m<60? m+' 分' : (Math.floor(m/60)+' 時間 '+(m%60)+' 分');}
function safe(path, fb){try{var v=path(); return (v===undefined||v===null)?fb:v;}catch(e){return fb;}}
function kmStr(m){ return (m/1000).toFixed(2) + ' km'; }
function fmtLatLon(lat, lon){ return (lat.toFixed(5) + ', ' + lon.toFixed(5)); }
function mean(arr){ if(!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function variance(arr){ if(!arr.length) return 0; const m=mean(arr); return arr.reduce((s,x)=>s+(x-m)*(x-m),0)/arr.length; }
function stddev(arr){ return Math.sqrt(variance(arr)); }

/* 乱数（シード付き） */
function mulberry32(seed){ let t = seed>>>0; return function(){ t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296; };}
function normal01(rng){ let u=0,v=0; while(u===0)u=rng(); while(v===0)v=rng(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }
function sampleNormal(m,v,rng){ const sd=Math.sqrt(Math.max(0,v)); return m+sd*normal01(rng); }

/* ===== 状態 ===== */
var pts=[], map, markerLayer, routeLayers={}, lastDirTs=0;
var lastFastest=null,lastMass=0,lastFlat=18;
var _statForceResampleFlag=false;
var poiLayer=null, pairCache=new Map();

/* ===== 初期化 ===== */
window.addEventListener('DOMContentLoaded',function(){
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'©OpenStreetMap'}).addTo(map);
  map.createPane('routeSlope').style.zIndex=690;
  map.createPane('routeShortest').style.zIndex=700;
  map.createPane('routeFastest').style.zIndex=710;

  $('searchBtn').onclick = function(){var q=$('placeInput').value.trim(); if(q) nomSearch(q);};
  $('locBtn').onclick = addCurrent;
  $('drawBtn').onclick = drawRoutes;

  $('btnDownloadTime').onclick = ()=>downloadEnergyGraphByTime(lastFastest,lastMass,lastFlat);
  $('btnDownloadDist').onclick = ()=>downloadEnergyGraphByDistance(lastFastest,lastMass,lastFlat);

  $('restModeBtn').onclick = function(){
    $('restToggle').checked=!$('restToggle').checked;
    $('restModeBtn').textContent='休憩込み: '+($('restToggle').checked?'ON':'OFF');
    drawRoutes();
  };
  $('restBasis').onchange = function(e){
    var v=e.target.value;
    $('timeBox').style.display     =(v==='time'?'inline-flex':'none');
    $('energyBox').style.display   =(v==='energy'?'inline-flex':'none');
    $('distanceBox').style.display =(v==='distance'?'inline-flex':'none');
  };
  document.addEventListener('click',e=>{
    var b=e.target.closest?e.target.closest('.presetKJ'):null;
    if(b) $('restKJ').value=b.getAttribute('data-kj');
  });

  $('statMetric').onchange = function(){
    const m = $('statMetric').value;
    $('statMeanUnit').textContent = (m==='distance'?'km':'kJ');
    $('statVarUnit').textContent  = (m==='distance'?'km²':'kJ²');
    $('statMinUnit').textContent  = (m==='distance'?'km':'kJ');
  };
  $('statResampleBtn').onclick = function(){ _statForceResampleFlag=true; };

  $('btnCalcLegs').onclick = calcLegsAndRender;
  $('legMetric').onchange = calcLegsAndRender;
  $('legIncludeRest').onchange = calcLegsAndRender;

  $('btnCollectCands').onclick = async ()=>{
    $('optStatus').textContent='候補収集中...';
    await buildRestCandidatesForAll();
    $('optStatus').textContent='候補収集完了。';
    $('btnOptimize').disabled=false;
  };
  $('btnOptimize').onclick = async ()=>{
    $('optStatus').textContent='最適化中...';
    const best = await optimizeCombination();
    if(best){
      applyBestToPts(best);
      $('optResult').textContent = `最適コスト=${best.cost.toFixed(3)} / 区間数=${best.legs.length}`;
      await drawRoutes(); // 適用後に再描画
    }else{
      $('optResult').textContent = '適切な組合せが見つかりませんでした。';
    }
    $('optStatus').textContent='';
  };

  initSortable();
});

/* ===== 検索 ===== */
async function nomSearch(q){
  var url='https://nominatim.openstreetmap.org/search?format=json&limit=10&q='+encodeURIComponent(q);
  if($('nearbyOnly').checked){
    var b=map.getBounds();
    url+='&viewbox='+[b.getWest(),b.getNorth(),b.getEast(),b.getSouth()].join(',')+'&bounded=1';
  }
  var arr=await (await fetch(url)).json();
  var ul=$('searchResults'); ul.innerHTML=''; ul.hidden=!arr.length;
  arr.forEach(function(o){
    var li=document.createElement('li'); li.textContent=o.display_name;
    li.onclick=function(){addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});ul.hidden=true;$('placeInput').value='';};
    ul.appendChild(li);
  });
}

/* ===== リスト ===== */
function addPoint(p){p.type=pts.length?'':'start'; pts.forEach(d=>{if(d.type==='goal') d.type='via';}); pts.push(p); if(pts.length>1) pts[pts.length-1].type='goal'; drawList();}
function drawList(){
  var ul=$('pointList'); ul.innerHTML='';
  pts.forEach(function(p,i){
    var li=document.createElement('li'); li._idx=i;

    const title = document.createElement('span');
    title.textContent = p.name + (p.isRest?'（休憩）':'');
    li.appendChild(title);

    var del=document.createElement('button'); del.className='del'; del.textContent='×';
    del.onclick=function(e){e.stopPropagation(); pts.splice(i,1); fixType(); drawList();};
    li.appendChild(del);

    if(p.isRest){
      // 候補表示
      const wrap = document.createElement('div'); wrap.style.width='100%'; wrap.style.marginTop='4px';
      if(Array.isArray(p.restCandidates) && p.restCandidates.length){
        const details=document.createElement('details'); details.open=false;
        const sum=document.createElement('summary'); sum.textContent=`候補（${p.restCandidates.length}件）`; sum.style.cursor='pointer'; sum.style.fontSize='0.9em';
        details.appendChild(sum);
        const ul2=document.createElement('ul'); ul2.style.listStyle='disc'; ul2.style.margin='4px 0 0 16px'; ul2.style.padding='0';
        p.restCandidates.forEach((c,idx)=>{
          const li2=document.createElement('li');
          li2.textContent=`#${idx+1} ${c.name||'POI'} / ${fmtLatLon(c.lat,c.lon)} / ${(c._d||0).toFixed(0)}m`;
          ul2.appendChild(li2);
        });
        details.appendChild(ul2);
        wrap.appendChild(details);
      }
      li.appendChild(wrap);
    }
    ul.appendChild(li);
  });
}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function initSortable(){ new Sortable($('pointList'),{animation:150,handle:'span',onEnd:function(){pts=Array.from($('pointList').children).map(li=>pts[li._idx]); fixType(); drawList();}}); }

/* ===== 現在地 ===== */
function addCurrent(){navigator.geolocation.getCurrentPosition(p=>addPoint({name:'現在地',lat:p.coords.latitude,lon:p.coords.longitude}),()=>alert('現在地取得失敗'));}

/* ===== ORS ===== */
async function post(url,body){
  var r=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json','Authorization':ORS_KEY},body:JSON.stringify(body)});
  if(!r.ok) throw new Error(r.status); return r.json();
}
async function dir(body,profile){
  var wait=1100-(Date.now()-lastDirTs); if(wait>0) await sleep(wait);
  var d=await post(ORS_ROOT+'/v2/directions/'+profile+'/geojson',body); lastDirTs=Date.now(); return d;
}

/* ===== エネルギー ===== */
function energyStepKJ(d,dz,m,flat){return flat*(d/1000)+Math.max(dz,0)*m*9.80665/1000;}

/* ===== 距離累積 ===== */
function buildCumDistArray(coords){
  var cd=[0];
  for(var i=1;i<coords.length;i++){
    var lon=coords[i][0], lat=coords[i][1], plon=coords[i-1][0], plat=coords[i-1][1];
    cd[i]=cd[i-1]+L.latLng(lat,lon).distanceTo([plat,plon]);
  }
  return cd;
}

/* ===== グラフ（略：既存通り） ===== */
function tempShowChartsContainer(show){var c=$('charts'); if(show){c.style.display='block';c.style.position='absolute';c.style.left='-99999px';c.style.visibility='hidden';}else{c.removeAttribute('style');c.style.display='none';}}
function prepareCanvasSize(canvas,w,h){canvas.width=w||1600;canvas.height=h||900;}
function deriveSeriesFromCoords(feature){
  const coords = feature.geometry.coordinates || [];
  const hasEle = coords[0] && coords[0].length >= 3;
  const summary = (feature.properties && feature.properties.summary) || {distance:0, duration:0};
  const totalD = +summary.distance || 0;
  const totalT = +summary.duration || 0;
  const segD = [], segDZ = [];
  for(let i=1;i<coords.length;i++){
    const [lon, lat] = coords[i]; const [plon, plat] = coords[i-1];
    const d = L.latLng(lat, lon).distanceTo([plat, plon]);
    segD.push(d); segDZ.push(hasEle?((coords[i][2]||0)-(coords[i-1][2]||0)):0);
  }
  return { segD, segDZ, totalDist: totalD, totalTime: totalT };
}
function buildEnergyTimeSeriesBySteps(feature, mass, flat){
  const coords = feature.geometry.coordinates; const hasEle = coords[0].length >= 3;
  const segs = (feature.properties.segments || []); const stepsExist = segs.some(s=>Array.isArray(s.steps)&&s.steps.length);
  if(stepsExist){
    let cumT=0,cumE=0,tMin=[],eKJ=[];
    for(const s of segs){ for(const st of (s.steps||[])){ const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, dt=st.duration||0, dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0;
      cumT+=dt; cumE+=energyStepKJ(d,dz,lastMass,lastFlat); tMin.push((cumT/60).toFixed(2)); eKJ.push(+cumE.toFixed(1)); } }
    return { labels:tMin, values:eKJ, xlabel:'時間 (分)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_time.png' };
  }
  const { segD, segDZ, totalDist, totalTime } = deriveSeriesFromCoords(feature);
  let cumE=0,cumT=0; const labels=[],values=[];
  for(let i=0;i<segD.length;i++){ const d=segD[i], dz=segDZ[i], dE=energyStepKJ(d,dz,lastMass,lastFlat);
    const dt = totalTime>0 ? (d/Math.max(1,totalDist))*totalTime : 0; cumT+=dt; cumE+=dE; labels.push((cumT/60).toFixed(2)); values.push(+cumE.toFixed(1)); }
  if(totalTime>0 && labels.length){ labels[labels.length-1]=(totalTime/60).toFixed(2); }
  return { labels, values, xlabel:'時間 (分)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_time.png' };
}
function buildEnergyDistanceSeriesBySteps(feature, mass, flat){
  const coords = feature.geometry.coordinates; const hasEle = coords[0].length>=3;
  const segs = (feature.properties.segments || []); const stepsExist = segs.some(s=>Array.isArray(s.steps)&&s.steps.length);
  if(stepsExist){
    let cumD=0,cumE=0,km=[],eKJ=[];
    for(const s of segs){ for(const st of (s.steps||[])){ const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0, dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0; cumD+=d; cumE+=energyStepKJ(d,dz,lastMass,lastFlat);
      km.push((cumD/1000).toFixed(2)); eKJ.push(+cumE.toFixed(1)); } }
    return { labels:km, values:eKJ, xlabel:'距離 (km)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_distance.png' };
  }
  const { segD, segDZ } = deriveSeriesFromCoords(feature);
  let cumD=0,cumE=0; const km=[],eKJ=[];
  for(let i=0;i<segD.length;i++){ const d=segD[i], dz=segDZ[i]; cumD+=d; cumE+=energyStepKJ(d,dz,lastMass,lastFlat); km.push((cumD/1000).toFixed(2)); eKJ.push(+cumE.toFixed(1)); }
  return { labels:km, values:eKJ, xlabel:'距離 (km)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_distance.png' };
}
async function downloadLineChart(obj){
  tempShowChartsContainer(true); const ec=$('energyChart'); prepareCanvasSize(ec,1600,900);
  const cfg={type:'line',data:{labels:obj.labels,datasets:[{label:obj.ylabel,data:obj.values,borderWidth:2,pointRadius:0}]},
    options:{animation:false,plugins:{legend:{display:false}},scales:{x:{title:{display:true,text:obj.xlabel}},y:{title:{display:true,text:obj.ylabel}}}}};
  const chart=new Chart(ec,cfg); await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));
  const tryBlob=()=>new Promise(res=>{ec.toBlob(b=>res(b),'image/png');});
  let blob=await tryBlob(); if(!blob){await new Promise(r=>setTimeout(r,50)); blob=await tryBlob();}
  if(blob){ const u=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=u; a.download=obj.filename; a.click();
    setTimeout(()=>{URL.revokeObjectURL(u); chart.destroy(); tempShowChartsContainer(false);},300);
  }else{ const url=ec.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download=obj.filename; a.click();
    setTimeout(()=>{ chart.destroy(); tempShowChartsContainer(false); },300); }
}
function downloadEnergyGraphByTime(f,mass,flat){ if(!f){alert('先にルートを描画');return;} downloadLineChart(buildEnergyTimeSeriesBySteps(f,mass,flat)); }
function downloadEnergyGraphByDistance(f,mass,flat){ if(!f){alert('先にルートを描画');return;} downloadLineChart(buildEnergyDistanceSeriesBySteps(f,mass,flat)); }

/* ===== デバッグ ===== */
function renderRestDebug(log){
  var el=$('restDebug'); if(!el) return; if(!log||!log.length){el.innerHTML='（なし）'; return;}
  log.sort((a,b)=>a.at===b.at? (a.event||'').localeCompare(b.event||'') : a.at-b.at);
  var rows=log.map(function(r){
    var head='['+(r.kind||'')+'] '+kmStr(r.at)+' ';
    if(r.event==='TRIGGER'){
      var unit=(r.metric==='distance'?'km':r.metric==='energy'?'kJ':r.metric==='sec'?'s':'');
      var tgt=(typeof r.target!=='undefined')?(' target='+(unit==='km'?(+r.target).toFixed(2):(+r.target).toFixed(1))+unit):'';
      return head+'→ TRIGGER'+tgt;
    }else if(r.event==='HIT'){ return head+'→ HIT'; }
    return head+'→ '+(r.event||'');
  });
  el.innerHTML='<pre style="margin:0; white-space:pre-wrap;">'+rows.join('\n')+'</pre>';
}

/* ===== 休憩生成 ===== */
function mergeByRouteD(points, tolM){ const tol=Math.max(1,Number(tolM)||20); points.sort((a,b)=>a.routeD-b.routeD);
  const out=[]; for(const p of points){ const last=out[out.length-1]; if(last && Math.abs(last.routeD-p.routeD)<=tol) continue; out.push(p);} return out; }

async function makeRestSimple(previewFeature,basis,mass,flat,thr){
  const coords = previewFeature.geometry.coordinates;
  const segs = safe(()=>previewFeature.properties.segments,[])||[]; const hasEle=(coords[0].length>=3);
  const cum = buildCumDistArray(coords); let debug=[], rawPoints=[];

  if($('optStatTrigger').checked){
    const seed=Number($('statSeed').value)||12345; const rng=mulberry32(seed);
    const metric=$('statMetric').value; const meanV=Number($('statMean').value)||0;
    const vari=Math.max(0,Number($('statVar').value)||0); const minV=Math.max(0.001,Number($('statMin').value)||0.001);
    function drawTarget(){ let t=sampleNormal(meanV,vari,rng); if(!isFinite(t)) t=meanV; return Math.max(minV,t); }
    let targetNext=drawTarget(), acc=0;
    for(const s of segs){ const steps=s.steps||[];
      for(const st of steps){ const [i0,i1]=st.way_points||[0,0]; const d=st.distance||0; const dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0;
        const dE=energyStepKJ(d,dz,mass,flat); const dDkm=d/1000; acc += (metric==='distance') ? dDkm : dE;
        while(acc>=targetNext){ const routeD=cum[i1];
          rawPoints.push({name:'休憩',lat:coords[i1][1],lon:coords[i1][0],routeD});
          debug.push({kind:(metric==='distance'?'ACCUM_DIST':'ACCUM_ENE'),at:routeD,event:'TRIGGER',target:targetNext,metric:metric});
          debug.push({kind:(metric==='distance'?'ACCUM_DIST':'ACCUM_ENE'),at:routeD,event:'HIT'});
          let nextT=drawTarget(); if(_statForceResampleFlag){nextT=drawTarget(); _statForceResampleFlag=false;}
          acc-=targetNext; targetNext=nextT; }
      }
    }
  }

  if($('optAccum').checked){
    let acc=0;
    for(const s of segs){ const steps=s.steps||[];
      for(const st of steps){ const [i0,i1]=st.way_points||[0,0]; const d=st.distance||0, t=st.duration||0;
        const dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0; const dE=energyStepKJ(d,dz,mass,flat);
        if(basis==='time') acc+=t; else if(basis==='energy') acc+=dE; else acc+=d/1000;
        if(acc>=thr){ const routeD=cum[i1]; rawPoints.push({name:'休憩',lat:coords[i1][1],lon:coords[i1][0],routeD});
          debug.push({kind:'ACCUM',at:routeD,event:'TRIGGER',target:thr,metric:(basis==='time'?'sec':(basis==='energy'?'energy':'distance'))});
          debug.push({kind:'ACCUM',at:routeD,event:'HIT'}); acc=0; }
      }
    }
  }

  const merged = mergeByRouteD(rawPoints, 20).map(p=>({name:p.name,lat:p.lat,lon:p.lon,type:'via',isRest:true}));
  window._restDebug = debug;
  return merged;
}

/* ===== Overpass（POI） ===== */
function poiCategoryToOverpass(block, lat, lon, radiusM){
  const A=`around:${Math.max(10,radiusM)},${lat},${lon}`;
  switch(block){
    case 'conv': return `(node["amenity"="convenience"](${A}); way["amenity"="convenience"](${A}););`;
    case 'super': return `(node["shop"="supermarket"](${A}); way["shop"="supermarket"](${A}););`;
    case 'drug': return `(node["shop"="chemist"](${A}); way["shop"="chemist"](${A}); node["shop"="pharmacy"](${A}); way["shop"="pharmacy"](${A}););`;
    default: return ``;
  }
}
async function overpassFetch(query){
  const url='https://overpass-api.de/api/interpreter'; const body=`data=${encodeURIComponent(query)}`;
  let delay=800; for(let i=0;i<5;i++){ const r=await fetch(url,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body});
    if(r.ok) return r.json(); if(r.status===429||r.status===504||r.status===502){ await sleep(delay); delay=Math.min(5000,Math.round(delay*1.8)); continue; }
    throw new Error('Overpass '+r.status); }
  throw new Error('Overpass retry exceeded');
}
async function fetchPoisAround(lat, lon, radiusM, selectedKeys){
  const all=[]; for(let i=0;i<selectedKeys.length;i++){
    const key=selectedKeys[i]; const block=poiCategoryToOverpass(key,lat,lon,radiusM); if(!block) continue;
    const query=`[out:json][timeout:25];(${block});out center 30;`;
    try{ if(i>0) await sleep(250);
      const data=await overpassFetch(query); const elements=data.elements||[];
      elements.forEach(e=>{
        const ll = e.type==='node' ? [e.lat,e.lon] : (e.center ? [e.center.lat,e.center.lon] : null); if(!ll) return;
        const name=(e.tags&&(e.tags['name:ja']||e.tags.name))||(e.tags&&e.tags.brand)||'POI'; all.push({name,lat:ll[0],lon:ll[1],cat:key});
      });
    }catch(err){ console.warn('POI取得失敗('+key+')',err); }
  }
  const out=[]; all.sort((a,b)=> a.lat-b.lat || a.lon-b.lon || a.name.localeCompare(b.name));
  for(const p of all){ const last=out[out.length-1]; if(last){ const d=L.latLng(p.lat,p.lon).distanceTo([last.lat,last.lon]); if(d<=10 && p.name===last.name) continue; } out.push(p); }
  return out;
}

/* ===== ルート描画 ===== */
async function drawRoutes(){
  $('btnDownloadTime').disabled=true; $('btnDownloadDist').disabled=true; lastFastest=null;
  renderRestDebug([]); window._restDebug=[];

  if(pts.length<2){alert('2地点以上登録してください');return;}

  Object.keys(routeLayers).forEach(k=>{if(routeLayers[k]) map.removeLayer(routeLayers[k]);}); routeLayers={};
  if(markerLayer) map.removeLayer(markerLayer);

  // 以前の休憩を除去
  pts = pts.filter(p=>!p.isRest); fixType(); drawList();

  var profile=$('profileSelect').value;
  var mass=Number($('riderWeight').value)+Number($('bikeWeight').value);
  var flat=Number($('flatKJperKm').value);
  var basis=$('restBasis').value;

  var thr; if(basis==='time'){ thr=(Number($('restMinutes').value)||60)*60; }
  else if(basis==='energy'){ thr=Number($('restKJ').value)||500; }
  else { thr=Number($('restKm').value)||20; }

  // 休憩プレビュー
  try{
    if($('restToggle').checked){
      var preview=await dir({coordinates:pts.map(p=>[p.lon,p.lat]),elevation:true,extra_info:['steepness'],preference:'fastest'},profile);
      var feat=safe(()=>preview.features[0],null);
      if(feat){
        var rests=await makeRestSimple(feat,basis,mass,flat,thr);
        if(rests.length){
          var insertPos=Math.max(pts.length-1,1); Array.prototype.splice.apply(pts,[insertPos,0].concat(rests));
          fixType(); drawList();
        }
        if(typeof window._restDebug!=='undefined'){ renderRestDebug(window._restDebug); }

        // 候補を即時収集（POIトグルON時のみ地図にも可視化）
        await buildRestCandidatesForAll();

        if(poiLayer){ map.removeLayer(poiLayer); poiLayer=null; }
        const poiOn=$('poiToggle')&&$('poiToggle').checked;
        if(poiOn){
          const radius=Number($('poiRadius').value)||300;
          const restPts=pts.filter(p=>p.isRest);
          if(restPts.length){
            poiLayer=L.layerGroup().addTo(map);
            restPts.forEach(rp=>{
              (rp.restCandidates||[]).forEach(po=>{
                const labelCat = (po.cat==='conv'?'コンビニ':po.cat==='super'?'スーパー':'ドラッグストア');
                const m=L.marker([po.lat,po.lon],{icon:icon('purple')}).bindTooltip(`${labelCat}: ${po.name}`);
                poiLayer.addLayer(m);
              });
            });
          }
        }
      }
    }
  }catch(e){ console.warn('休憩地点取得失敗',e); }

  // マーカー
  markerLayer=L.layerGroup().addTo(map);
  pts.forEach(function(p){
    var ic=p.type==='start'?ICONS.start:(p.type==='goal'?ICONS.goal:ICONS.via);
    const tip = p.name + (p.isRest ? '（休憩）' : '') + (p.isRest ? '\n' + fmtLatLon(p.lat,p.lon) : '');
    markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ic}).bindTooltip(tip));
  });

  // ルート描画
  var coords=pts.map(p=>[p.lon,p.lat]); var base={coordinates:coords,elevation:true,extra_info:['steepness']};
  try{
    var shortest=await dir(Object.assign({},base,{preference:'shortest'}),profile);
    var fastest =await dir(Object.assign({},base,{preference:'fastest'}),profile);
    var slope = shortest.features[0];
    if(coords.length===2){
      var alt=await dir(Object.assign({},base,{preference:'shortest',alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}}),profile);
      var feats=alt.features||[];
      if(feats.length){
        function steepSum(f){ var vals=safe(()=>f.properties.extras.steepness.values,[]); var s=0; for(var i=0;i<vals.length;i++){ s+=Math.abs(vals[i][2]||0);}return s; }
        slope=feats.reduce((a,b)=>steepSum(a)<steepSum(b)?a:b);
      }
    }

    routeLayers.short=L.geoJSON(shortest.features[0],{pane:'routeShortest',style:{color:'#ff0000',weight:6}}).addTo(map);
    routeLayers.fast =L.geoJSON(fastest.features[0] ,{pane:'routeFastest', style:{color:'#0066ff',weight:6,dashArray:'4 4'}}).addTo(map);
    routeLayers.slope=L.geoJSON(slope               ,{pane:'routeSlope' , style:{color:'#ff9900',weight:6,opacity:0.9}}).addTo(map);
    updateLayerVisibility();

    var bounds=new L.LatLngBounds();
    markerLayer.eachLayer(l=>bounds.extend(l.getLatLng()));
    Object.keys(routeLayers).forEach(k=>bounds.extend(routeLayers[k].getBounds()));
    if(bounds.isValid()) map.fitBounds(bounds.pad(0.1));

    var s1=shortest.features[0].properties.summary, s2=fastest.features[0].properties.summary, s3=slope.properties.summary;
    $('routeInfo').innerHTML=
      '<b>最短</b> '+formatDist(s1.distance)+' / '+formatDur(s1.duration)+'<br>'+
      '<b>最速</b> '+formatDist(s2.distance)+' / '+formatDur(s2.duration)+'<br>'+
      '<b>勾配</b> '+formatDist(s3.distance)+' / '+formatDur(s3.duration);
    $('distanceScore').textContent='距離差: '+(s2.distance-s1.distance).toFixed(0)+' m';

    lastFastest=fastest.features[0]; lastMass=mass; lastFlat=flat;

    const testA=buildEnergyTimeSeriesBySteps(lastFastest,lastMass,lastFlat);
    const testB=buildEnergyDistanceSeriesBySteps(lastFastest,lastMass,lastFlat);
    $('btnDownloadTime').disabled=!(testA.labels&&testA.labels.length>1);
    $('btnDownloadDist').disabled=!(testB.labels&&testB.labels.length>1);

    await calcLegsAndRender();
  }catch(e){ console.error(e); alert('ルート取得失敗: '+e.message); }
}
function updateLayerVisibility(){
  var m={short:'chkShortest',fast:'chkFastest',slope:'chkSlope'};
  Object.keys(routeLayers).forEach(k=>{ if($(m[k]).checked) routeLayers[k].addTo(map); else map.removeLayer(routeLayers[k]); });
}

/* ===== 区間集計 ===== */
function buildLegPairs(includeRest){
  const list = pts.filter(p=>{
    if(p.type==='start'||p.type==='goal'||p.type==='via'){ return includeRest?true:!p.isRest; }
    return false;
  });
  const pairs=[]; for(let i=0;i<list.length-1;i++){ pairs.push({a:list[i],b:list[i+1],idx:i}); } return pairs;
}
async function calcLeg(profile, mass, flat, a, b){
  const body={coordinates:[[a.lon,a.lat],[b.lon,b.lat]],elevation:true,extra_info:['steepness'],preference:'fastest'};
  const res=await dir(body,profile); const f=res && res.features && res.features[0]; if(!f) return {km:NaN,kJ:NaN,feature:null};
  const km=((f.properties && f.properties.summary && f.properties.summary.distance)||0)/1000;
  let totalKJ=0; const coords=f.geometry.coordinates||[]; const hasEle=coords[0]&&coords[0].length>=3; const segs=(f.properties.segments||[]);
  const stepsExist=segs.some(s=>Array.isArray(s.steps)&&s.steps.length);
  if(stepsExist){ for(const s of segs){ for(const st of (s.steps||[])){ const [i0,i1]=st.way_points||[0,0]; const d=st.distance||0; const dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0; totalKJ+=energyStepKJ(d,dz,mass,flat); } } }
  else { const {segD,segDZ}=deriveSeriesFromCoords(f); for(let i=0;i<segD.length;i++){ totalKJ+=energyStepKJ(segD[i],segDZ[i],mass,flat); } }
  return {km, kJ:+totalKJ.toFixed(1), feature:f};
}
function renderLegTable(rows){
  const tbody=document.querySelector('#legTable tbody'); tbody.innerHTML='';
  rows.forEach((r,i)=>{
    const tr=document.createElement('tr');
    function td(txt,right){ const el=document.createElement('td'); el.textContent=txt; el.style.padding='4px'; if(right) el.style.textAlign='right'; return el; }
    tr.appendChild(td(String(i+1),false));
    tr.appendChild(td(r.label||'',false));
    tr.appendChild(td(isFinite(r.km)? r.km.toFixed(2):'-',true));
    tr.appendChild(td(isFinite(r.kJ)? r.kJ.toFixed(1):'-',true));
    tbody.appendChild(tr);
  });
}
function renderLegSummary(vals,metric){
  const unit=metric==='distance'?'km':'kJ'; const m=mean(vals), v=variance(vals), s=stddev(vals);
  $('legSummary').textContent=`指標=${metric==='distance'?'距離':'エネルギー'} / n=${vals.length} / 平均=${m.toFixed(3)} ${unit} / 分散=${v.toFixed(3)} ${unit}² / 標準偏差=${s.toFixed(3)} ${unit}`;
}
async function calcLegsAndRender(){
  if(pts.length<2){ $('legSummary').textContent='2地点以上登録してください'; renderLegTable([]); return; }
  const profile=$('profileSelect').value; const mass=Number($('riderWeight').value)+Number($('bikeWeight').value); const flat=Number($('flatKJperKm').value);
  const includeRest=$('legIncludeRest').checked;
  const pairs=buildLegPairs(includeRest); if(!pairs.length){ $('legSummary').textContent='対象区間がありません'; renderLegTable([]); return; }
  const rows=[]; for(const p of pairs){ try{ const r=await calcLeg(profile,mass,flat,p.a,p.b); const label=(p.a.name||'A')+' → '+(p.b.name||'B'); rows.push({label,km:r.km,kJ:r.kJ}); }catch(e){ const label=(p.a.name||'A')+' → '+(p.b.name||'B'); rows.push({label,km:NaN,kJ:NaN}); } }
  renderLegTable(rows);
  const metric=$('legMetric').value; const vals=rows.map(r=>metric==='distance'? r.km : r.kJ).filter(x=>isFinite(x));
  if(vals.length){ renderLegSummary(vals, metric); } else { $('legSummary').textContent='有効な値がありません'; }
}

/* ===== 最適化 追加分 ===== */
async function buildRestCandidatesForAll(){
  const radius=Number($('poiRadius').value)||300;
  const cats=Array.from(document.querySelectorAll('.poiCat:checked')).map(x=>x.value);
  const rests=pts.filter(p=>p.isRest);
  for(let i=0;i<rests.length;i++){
    const r=rests[i];
    try{
      if(i>0) await sleep(300);
      const pois=await fetchPoisAround(r.lat,r.lon,radius,cats);
      pois.forEach(po=>po._d=L.latLng(r.lat,r.lon).distanceTo([po.lat,po.lon]));
      r.restCandidates = pois.sort((a,b)=>a._d-b._d).slice(0,3);
    }catch(e){ console.warn('候補収集失敗',e); r.restCandidates=[]; }
  }
  drawList();
}
function buildGroupsFromPts(){
  const start=pts.find(p=>p.type==='start');
  const goal =pts.find(p=>p.type==='goal');
  const restGroups=pts.filter(p=>p.isRest).map(p=>{
    if(Array.isArray(p.restCandidates) && p.restCandidates.length){
      return p.restCandidates.map(c=>({name:c.name||'候補',lat:c.lat,lon:c.lon}));
    }
    return [{name:p.name,lat:p.lat,lon:p.lon}];
  });
  return [[{name:start.name,lat:start.lat,lon:start.lon}], ...restGroups, [{name:goal.name,lat:goal.lat,lon:goal.lon}]];
}
async function getPairMetrics(a,b,profile,mass,flat){
  const key=`${a.lon.toFixed(6)},${a.lat.toFixed(6)}|${b.lon.toFixed(6)},${b.lat.toFixed(6)}`;
  if(pairCache.has(key)) return pairCache.get(key);
  const r=await calcLeg(profile,mass,flat,a,b);
  const sec=safe(()=>r.feature.properties.summary.duration,0);
  const val={ km:r.km, min:sec/60, kJ:r.kJ };
  pairCache.set(key,val);
  return val;
}
function getOptConfig(){
  return {
    useDist: $('useDist').checked, meanDist:+$('meanDist').value, varDist:+$('varDist').value, wDist:+$('wDist').value,
    useTime: $('useTime').checked, meanTime:+$('meanTime').value, varTime:+$('varTime').value, wTime:+$('wTime').value,
    useEner: $('useEner').checked, meanKJ:+$('meanKJ').value,   varKJ:+$('varKJ').value,   wEner:+$('wEner').value,
    beamWidth: Math.max(3, +$('beamWidth').value||30)
  };
}
function evalCostFromSeries(series, cfg){
  let cost=0;
  if(cfg.useDist){ const xs=series.map(s=>s.km); const m=mean(xs), v=variance(xs); cost += cfg.wDist*((m-cfg.meanDist)**2 + (v-cfg.varDist)**2); }
  if(cfg.useTime){ const xs=series.map(s=>s.min); const m=mean(xs), v=variance(xs); cost += cfg.wTime*((m-cfg.meanTime)**2 + (v-cfg.varTime)**2); }
  if(cfg.useEner){ const xs=series.map(s=>s.kJ); const m=mean(xs), v=variance(xs); cost += cfg.wEner*((m-cfg.meanKJ)**2 + (v-cfg.varKJ)**2); }
  return cost;
}
async function optimizeCombination(){
  const cfg=getOptConfig();
  const profile=$('profileSelect').value;
  const mass=Number($('riderWeight').value)+Number($('bikeWeight').value);
  const flat=Number($('flatKJperKm').value);
  const groups=buildGroupsFromPts(); if(groups.length<2) return null;

  let beam=[{ node: groups[0][0], path:[groups[0][0]], legs:[], cost:0 }];
  for(let gi=1; gi<groups.length; gi++){
    const nextGroup=groups[gi]; const newBeam=[];
    for(const state of beam){
      for(const cand of nextGroup){
        const met=await getPairMetrics(state.node,cand,profile,mass,flat);
        const legs=state.legs.concat([met]);
        const cost=evalCostFromSeries(legs, cfg);
        newBeam.push({ node:cand, path:state.path.concat([cand]), legs, cost });
      }
    }
    newBeam.sort((a,b)=>a.cost-b.cost);
    beam=newBeam.slice(0,cfg.beamWidth);
  }
  return beam[0]||null;
}
function applyBestToPts(best){
  if(!best||!best.path||best.path.length<2) return;
  const chosenRests=best.path.slice(1,best.path.length-1);
  let ri=0;
  for(const p of pts){
    if(p.isRest && chosenRests[ri]){
      const c=chosenRests[ri++];
      p.name = (p.name||'休憩').replace(/（休憩）?$/,'（休憩）');
      p.lat=c.lat; p.lon=c.lon;
    }
  }
}

/* ===== おまけ：ユーティリティ ===== */
async function drawOnceAndMaybeOptimize(){
  await drawRoutes();
}

/* 初回のヒント: マップだけ出す */
</script>
</body>
</html>
